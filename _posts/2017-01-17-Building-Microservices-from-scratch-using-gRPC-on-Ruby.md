---
layout: post
title: Building Microservices from scratch using gRPC on Ruby
---

Today, REST with JSON is the most popular framework amongst web developers for network communication. But, it is not very suitable for a microservice architecture mainly because of latency added by JSON data transmission / serializing / deserializing. 

My quest for finding an optimal network communication framework for microservices brought me to gRPC.  
"*gRPC is a modern, open source remote procedure call (RPC) framework that can run anywhere. It enables client and server applications to communicate transparently, and makes it easier to build connected systems.*"

To read more about benefits of gRPC, visit the official site [here](http://www.grpc.io/faq/).

Serialization in gRPC is based on [Protocol Buffers](https://developers.google.com/protocol-buffers/docs/overview), a language and platform independent serialization mechanism for structured data.   
"*Protocol buffers are a flexible, efficient, automated mechanism for serializing structured data – think XML, but smaller, faster, and simpler.*"

In the remaining part of this post, I will be walking you through setting up a simple gRPC server from scratch on Ruby. Let's build *Snip* - a dummy URL shortener!

We will divide our code structure into 3 separate repositories:

1. **`snip`** : contains the proto definitions and converted ruby files for client communication. Basically, this is like an interface between client and server, specifying the RPC methods, and the request an response formats.

2. **`snip-service`** : Service implementation for the RPC methods (This is where the gRPC server sits). 

3. **`X-app`** : This is any application who wishes to call snip-service for shortening URLs. 
 
**`snip`** will be packaged as a gem, and included in both **`snip-service`** and **`X-app`**.

### Step 1: Setup

First, make sure to create the 3 repositories. 
1. snip is supposed to be a ruby gem, so you could use the bundler scaffold for creating it: `bundle gem snip`
2. You can setup `snip-service` and `X-app` as plain ruby apps.
3. Install the required gems for grpc:

```
gem install grpc
gem install grpc-tools
```


### Step 2: Define proto files

Let's create a new file `proto/snip.proto`

```proto
syntax = "proto3";
package snip;

service UrlSnipService {
    rpc snip_it(SnipRequest) returns (SnipResponse) {}
}

message SnipRequest {
    string url = 1;
}

message SnipResponse {
    string url = 1;
}
```

### Step 3: Generate ruby bindings for the proto definition

Next, we are going to convert the defined proto files to ruby bindings, which are ultimately going to be used by both the client and the server.

```
grpc_tools_ruby_protoc -Iproto --ruby_out=lib --grpc_out=lib proto/snip.proto
```

My `snip` directory tree after this command:

```
├── Gemfile
├── Gemfile.lock
├── LICENSE
├── README.md
├── lib
│   ├── proto
│   │   ├── snip_pb.rb
│   │   └── snip_services_pb.rb
│   └── snip
│       └── version.rb
├── proto
│   └── snip.proto
└── snip.gemspec
```

Note that `snip_pb.rb` and `snip-services_pb.rb` are the important files which are required for client-server communication. This is how they should look:

#####`snip_pb.rb`

```
# Generated by the protocol buffer compiler.  DO NOT EDIT!
# source: snip.proto

require 'google/protobuf'

Google::Protobuf::DescriptorPool.generated_pool.build do
  add_message "snip.SnipRequest" do
    optional :url, :string, 1
  end
  add_message "snip.SnipResponse" do
    optional :url, :string, 1
  end
end

module Snip
  SnipRequest = Google::Protobuf::DescriptorPool.generated_pool.lookup("snip.SnipRequest").msgclass
  SnipResponse = Google::Protobuf::DescriptorPool.generated_pool.lookup("snip.SnipResponse").msgclass
end

```

#####`snip_services_pb.rb`

```
# Generated by the protocol buffer compiler.  DO NOT EDIT!
# Source: snip.proto for package 'snip'

require 'grpc'
require 'snip_pb'

module Snip
  module UrlSnipService
    class Service

      include GRPC::GenericService

      self.marshal_class_method = :encode
      self.unmarshal_class_method = :decode
      self.service_name = 'snip.UrlSnipService'

      rpc :snip_it, SnipRequest, SnipResponse
    end

    Stub = Service.rpc_stub_class
  end
end
```

